<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rose Textured Triangle Demo - Computer Graphics (WebGL)</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background-color: #1a1a1a;
            color: #ffffff;
            font-family: 'Arial', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }
        
        h1 {
            color: #4CAF50;
            margin-bottom: 10px;
        }
        
        .subtitle {
            color: #888;
            margin-bottom: 30px;
        }
        
        canvas {
            border: 2px solid #4CAF50;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            width: 400px;
            height: 400px;
        }
        
        .controls {
            margin-top: 15px;
            text-align: center;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 800px;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 3px;
            min-width: 80px;
        }
        
        .control-group label {
            font-size: 14px;
            color: #ccc;
        }
        
        .control-group input[type="range"] {
            width: 150px;
        }
        
        .control-group button {
            padding: 8px 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .control-group button:hover {
            background-color: #45a049;
        }
        
        .control-group button.active {
            background-color: #ff6b6b;
        }
        
        .info {
            margin-top: 15px;
            padding: 12px;
            background-color: #2a2a2a;
            border-radius: 8px;
            max-width: 600px;
        }
        
        .info h3 {
            color: #4CAF50;
            margin-top: 0;
        }
        
        .info ul {
            margin: 8px 0;
            padding-left: 20px;
        }
        
        .info li {
            margin: 3px 0;
        }
        
        .status {
            margin-top: 10px;
            padding: 10px;
            background-color: #333;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
        }
        
        .error {
            background-color: #4a1a1a;
            color: #ff6b6b;
        }
        
        .success {
            background-color: #1a4a1a;
            color: #4CAF50;
        }
        
        .loading {
            background-color: #4a4a1a;
            color: #ffff6b;
        }
    </style>
</head>
<body>
    <h1>ðŸŒ¹ Rose Textured Triangle Demo</h1>
    <p class="subtitle">WebGL Triangle with Rose Image Texture</p>
    
    <canvas id="glCanvas" width="800" height="600"></canvas>
    
    <div class="controls">
        <div class="control-group">
            <label>Rotation Speed:</label>
            <input type="range" id="rotationSlider" min="0" max="5" step="0.1" value="1">
            <span id="rotationValue">1.0</span>
        </div>
        
        <div class="control-group">
            <label>Scale:</label>
            <input type="range" id="scaleSlider" min="0.5" max="2" step="0.1" value="1">
            <span id="scaleValue">1.0</span>
        </div>
        
        <div class="control-group">
            <label>Color Tint:</label>
            <input type="range" id="redSlider" min="0" max="1" step="0.1" value="1">
            <input type="range" id="greenSlider" min="0" max="1" step="0.1" value="1">
            <input type="range" id="blueSlider" min="0" max="1" step="0.1" value="1">
        </div>
        
        <div class="control-group">
            <label>Texture Effects:</label>
            <button id="normalBtn" class="active">Normal</button>
            <button id="invertBtn">Invert</button>
            <button id="grayscaleBtn">Grayscale</button>
        </div>
        
        <div class="control-group">
            <button id="resetBtn">Reset</button>
            <button id="animateBtn" class="active">Animate</button>
        </div>
    </div>
    
    <div class="info">
        <h3>ðŸŽ® Controls</h3>
        <ul>
            <li><strong>Rotation Speed:</strong> Control triangle rotation speed</li>
            <li><strong>Scale:</strong> Resize the triangle</li>
            <li><strong>Color Tint:</strong> Adjust RGB color tinting</li>
            <li><strong>Texture Effects:</strong> Apply different texture effects</li>
            <li><strong>Reset:</strong> Reset all parameters to default</li>
            <li><strong>Animate:</strong> Toggle animation on/off</li>
        </ul>
        
        <h3>ðŸ”§ Technical Features</h3>
        <ul>
            <li><strong>Image Texture:</strong> Loads and displays rose.png image</li>
            <li><strong>Texture Coordinates:</strong> UV mapping for proper texture display</li>
            <li><strong>Uniform Variables:</strong> Real-time parameter control</li>
            <li><strong>Matrix Transformations:</strong> Rotation and scaling</li>
            <li><strong>Color Tinting:</strong> RGB color multiplication</li>
            <li><strong>Texture Effects:</strong> Invert, grayscale, and normal modes</li>
        </ul>
    </div>
    
    <div id="status" class="status">Initializing WebGL...</div>

    <script>
        class RoseTexturedTriangleRenderer {
            constructor() {
                this.canvas = document.getElementById('glCanvas');
                this.gl = null;
                this.program = null;
                this.vbo = null;
                this.texture = null;
                
                // Animation parameters
                this.rotation = 0;
                this.scale = 1.0;
                this.rotationSpeed = 1.0;
                this.animate = true;
                this.colorTint = [1.0, 1.0, 1.0];
                this.textureEffect = 0; // 0: normal, 1: invert, 2: grayscale
                
                // Uniform locations
                this.uniforms = {};
                
                this.init();
            }
            
            init() {
                try {
                    // Get WebGL context
                    this.gl = this.canvas.getContext('webgl') || this.canvas.getContext('experimental-webgl');
                    
                    if (!this.gl) {
                        throw new Error('WebGL not supported');
                    }
                    
                    this.updateStatus('WebGL context created successfully', 'success');
                    
                    // Create shaders and program
                    this.createShaders();
                    this.setupBuffers();
                    this.loadTexture();
                    this.setupEventListeners();
                    
                    // Start render loop
                    this.render();
                    
                } catch (error) {
                    this.updateStatus(`Error: ${error.message}`, 'error');
                    console.error('Initialization error:', error);
                }
            }
            
            createShaders() {
                const vertexShaderSource = `
                    attribute vec3 position;
                    attribute vec2 texCoord;
                    uniform mat4 model;
                    uniform mat4 view;
                    uniform mat4 projection;
                    varying vec2 vTexCoord;
                    
                    void main() {
                        gl_Position = projection * view * model * vec4(position, 1.0);
                        vTexCoord = texCoord;
                    }
                `;
                
                const fragmentShaderSource = `
                    precision mediump float;
                    varying vec2 vTexCoord;
                    uniform sampler2D texture1;
                    uniform vec3 colorTint;
                    uniform int textureEffect;
                    
                    void main() {
                        vec4 texColor = texture2D(texture1, vTexCoord);
                        
                        // Apply color tinting
                        texColor.rgb *= colorTint;
                        
                        // Apply texture effects
                        if (textureEffect == 1) {
                            // Invert
                            texColor.rgb = 1.0 - texColor.rgb;
                        } else if (textureEffect == 2) {
                            // Grayscale
                            float gray = dot(texColor.rgb, vec3(0.299, 0.587, 0.114));
                            texColor.rgb = vec3(gray);
                        }
                        
                        gl_FragColor = texColor;
                    }
                `;
                
                // Create and compile vertex shader
                const vertexShader = this.createShader(this.gl.VERTEX_SHADER, vertexShaderSource);
                
                // Create and compile fragment shader
                const fragmentShader = this.createShader(this.gl.FRAGMENT_SHADER, fragmentShaderSource);
                
                // Create program
                this.program = this.gl.createProgram();
                this.gl.attachShader(this.program, vertexShader);
                this.gl.attachShader(this.program, fragmentShader);
                this.gl.linkProgram(this.program);
                
                if (!this.gl.getProgramParameter(this.program, this.gl.LINK_STATUS)) {
                    throw new Error('Program linking failed: ' + this.gl.getProgramInfoLog(this.program));
                }
                
                // Get uniform locations
                this.uniforms.texture1 = this.gl.getUniformLocation(this.program, 'texture1');
                this.uniforms.model = this.gl.getUniformLocation(this.program, 'model');
                this.uniforms.view = this.gl.getUniformLocation(this.program, 'view');
                this.uniforms.projection = this.gl.getUniformLocation(this.program, 'projection');
                this.uniforms.colorTint = this.gl.getUniformLocation(this.program, 'colorTint');
                this.uniforms.textureEffect = this.gl.getUniformLocation(this.program, 'textureEffect');
                
                this.updateStatus('Shaders compiled and linked successfully', 'success');
            }
            
            createShader(type, source) {
                const shader = this.gl.createShader(type);
                this.gl.shaderSource(shader, source);
                this.gl.compileShader(shader);
                
                if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
                    const error = this.gl.getShaderInfoLog(shader);
                    this.gl.deleteShader(shader);
                    throw new Error(`Shader compilation failed: ${error}`);
                }
                
                return shader;
            }
            
            setupBuffers() {
                // Triangle vertices with positions and texture coordinates
                // Note: Flipped texture coordinates for OpenGL
                const vertices = new Float32Array([
                    // positions    // texture coords (flipped)
                     0.0,  0.5, 0.0,   0.5, 0.0,  // top
                    -0.5, -0.5, 0.0,   0.0, 1.0,  // bottom left
                     0.5, -0.5, 0.0,   1.0, 1.0   // bottom right
                ]);
                
                // Create VBO
                this.vbo = this.gl.createBuffer();
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vbo);
                this.gl.bufferData(this.gl.ARRAY_BUFFER, vertices, this.gl.STATIC_DRAW);
                
                // Get attribute locations
                this.positionLocation = this.gl.getAttribLocation(this.program, 'position');
                this.texCoordLocation = this.gl.getAttribLocation(this.program, 'texCoord');
                
                // Debug attribute locations
                console.log('Position location:', this.positionLocation);
                console.log('TexCoord location:', this.texCoordLocation);
                console.log('Texture location:', this.uniforms.texture1);
                
                this.updateStatus('Buffers created successfully', 'success');
            }
            
            loadTexture() {
                this.updateStatus('Loading rose texture...', 'loading');
                
                // Create texture
                this.texture = this.gl.createTexture();
                this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);
                
                // Set texture parameters for non-power-of-two textures
                this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
                this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
                this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
                this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
                
                // Load rose.png image
                const image = new Image();
                // Remove crossOrigin for local files
                // image.crossOrigin = 'anonymous';
                
                image.onload = () => {
                    console.log('Image loaded successfully:', image.width, 'x', image.height);
                    
                    // Bind texture before uploading
                    this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);
                    
                    // Upload image data to texture
                    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, image);
                    
                    // Generate mipmaps for better quality
                    this.gl.generateMipmap(this.gl.TEXTURE_2D);
                    
                    this.updateStatus(`Rose texture loaded successfully (${image.width}x${image.height})`, 'success');
                };
                
                image.onerror = (error) => {
                    console.error('Failed to load rose.png:', error);
                    this.updateStatus('Failed to load rose.png, using fallback texture', 'error');
                    this.createFallbackTexture();
                };
                
                // Add timeout to detect if image loading is stuck
                setTimeout(() => {
                    if (!image.complete) {
                        console.warn('Image loading timeout, using fallback');
                        this.updateStatus('Image loading timeout, using fallback texture', 'error');
                        this.createFallbackTexture();
                    }
                }, 3000);
                
                // Try to load rose.png from the same directory
                // For testing, you can comment out the next line and uncomment the line after
                image.src = 'rose.png';
                // image.src = 'nonexistent.png'; // Force fallback for testing
            }
            
            createFallbackTexture() {
                // Create a simple test texture as fallback
                const size = 64;
                const data = new Uint8Array(size * size * 4);
                
                for (let y = 0; y < size; y++) {
                    for (let x = 0; x < size; x++) {
                        const index = (y * size + x) * 4;
                        
                        // Create a simple checkerboard pattern
                        const checker = ((x / 8) + (y / 8)) % 2;
                        
                        if (checker < 1) {
                            // White squares
                            data[index] = 255;     // Red
                            data[index + 1] = 255; // Green
                            data[index + 2] = 255; // Blue
                            data[index + 3] = 255; // Alpha
                        } else {
                            // Red squares (like rose)
                            data[index] = 255;     // Red
                            data[index + 1] = 100; // Green
                            data[index + 2] = 100; // Blue
                            data[index + 3] = 255; // Alpha
                        }
                    }
                }
                
                // Upload fallback texture data
                this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, size, size, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, data);
                
                this.updateStatus('Fallback test texture created', 'success');
            }
            
            setupEventListeners() {
                // Texture effect buttons
                document.getElementById('normalBtn').addEventListener('click', () => {
                    this.textureEffect = 0;
                    this.updateEffectButtons();
                });
                
                document.getElementById('invertBtn').addEventListener('click', () => {
                    this.textureEffect = 1;
                    this.updateEffectButtons();
                });
                
                document.getElementById('grayscaleBtn').addEventListener('click', () => {
                    this.textureEffect = 2;
                    this.updateEffectButtons();
                });
                
                // Rotation speed slider
                const rotationSlider = document.getElementById('rotationSlider');
                const rotationValue = document.getElementById('rotationValue');
                rotationSlider.addEventListener('input', (e) => {
                    this.rotationSpeed = parseFloat(e.target.value);
                    rotationValue.textContent = this.rotationSpeed.toFixed(1);
                });
                
                // Scale slider
                const scaleSlider = document.getElementById('scaleSlider');
                const scaleValue = document.getElementById('scaleValue');
                scaleSlider.addEventListener('input', (e) => {
                    this.scale = parseFloat(e.target.value);
                    scaleValue.textContent = this.scale.toFixed(1);
                });
                
                // Color sliders
                const redSlider = document.getElementById('redSlider');
                const greenSlider = document.getElementById('greenSlider');
                const blueSlider = document.getElementById('blueSlider');
                
                [redSlider, greenSlider, blueSlider].forEach((slider, index) => {
                    slider.addEventListener('input', (e) => {
                        this.colorTint[index] = parseFloat(e.target.value);
                    });
                });
                
                // Reset button
                document.getElementById('resetBtn').addEventListener('click', () => {
                    this.reset();
                });
                
                // Animate button
                document.getElementById('animateBtn').addEventListener('click', () => {
                    this.animate = !this.animate;
                    this.updateAnimateButton();
                });
                
                // Window resize
                window.addEventListener('resize', () => {
                    this.resizeCanvas();
                });
            }
            
            updateEffectButtons() {
                const buttons = ['normalBtn', 'invertBtn', 'grayscaleBtn'];
                buttons.forEach((id, index) => {
                    const btn = document.getElementById(id);
                    btn.classList.toggle('active', index === this.textureEffect);
                });
            }
            
            updateAnimateButton() {
                const btn = document.getElementById('animateBtn');
                btn.classList.toggle('active', this.animate);
                btn.textContent = this.animate ? 'Animate' : 'Pause';
            }
            
            reset() {
                this.rotation = 0;
                this.scale = 1.0;
                this.rotationSpeed = 1.0;
                this.colorTint = [1.0, 1.0, 1.0];
                this.textureEffect = 0;
                this.animate = true;
                
                // Update UI
                document.getElementById('rotationSlider').value = 1.0;
                document.getElementById('rotationValue').textContent = '1.0';
                document.getElementById('scaleSlider').value = 1.0;
                document.getElementById('scaleValue').textContent = '1.0';
                document.getElementById('redSlider').value = 1.0;
                document.getElementById('greenSlider').value = 1.0;
                document.getElementById('blueSlider').value = 1.0;
                
                this.updateEffectButtons();
                this.updateAnimateButton();
            }
            
            resizeCanvas() {
                const rect = this.canvas.getBoundingClientRect();
                this.canvas.width = rect.width * window.devicePixelRatio;
                this.canvas.height = rect.height * window.devicePixelRatio;
                this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
            }
            
            createMatrices() {
                // Model matrix (rotation and scale)
                const model = this.createRotationMatrix(this.rotation);
                this.scaleMatrix(model, this.scale);
                
                // View matrix (identity for now)
                const view = this.createIdentityMatrix();
                
                // Projection matrix (orthographic)
                const projection = this.createOrthographicMatrix(-1, 1, -1, 1, -1, 1);
                
                // Set matrix uniforms
                this.gl.uniformMatrix4fv(this.uniforms.model, false, model);
                this.gl.uniformMatrix4fv(this.uniforms.view, false, view);
                this.gl.uniformMatrix4fv(this.uniforms.projection, false, projection);
                
                return { model, view, projection };
            }
            
            createIdentityMatrix() {
                return new Float32Array([
                    1, 0, 0, 0,
                    0, 1, 0, 0,
                    0, 0, 1, 0,
                    0, 0, 0, 1
                ]);
            }
            
            createRotationMatrix(angle) {
                const c = Math.cos(angle);
                const s = Math.sin(angle);
                return new Float32Array([
                    c, -s, 0, 0,
                    s,  c, 0, 0,
                    0,  0, 1, 0,
                    0,  0, 0, 1
                ]);
            }
            
            scaleMatrix(matrix, scale) {
                matrix[0] *= scale;
                matrix[5] *= scale;
                matrix[10] *= scale;
            }
            
            createOrthographicMatrix(left, right, bottom, top, near, far) {
                return new Float32Array([
                    2/(right-left), 0, 0, -(right+left)/(right-left),
                    0, 2/(top-bottom), 0, -(top+bottom)/(top-bottom),
                    0, 0, -2/(far-near), -(far+near)/(far-near),
                    0, 0, 0, 1
                ]);
            }
            
            render() {
                // Update rotation if animating
                if (this.animate) {
                    this.rotation += this.rotationSpeed * 0.02; // Adjust speed
                }
                
                // Clear canvas
                this.gl.clearColor(0.1, 0.1, 0.1, 1.0);
                this.gl.clear(this.gl.COLOR_BUFFER_BIT);
                
                // Use program
                this.gl.useProgram(this.program);
                
                // Create and set matrices
                this.createMatrices();
                
                // Bind texture
                this.gl.activeTexture(this.gl.TEXTURE0);
                this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);
                this.gl.uniform1i(this.uniforms.texture1, 0);
                
                // Set color tint and texture effect uniforms
                this.gl.uniform3fv(this.uniforms.colorTint, this.colorTint);
                this.gl.uniform1i(this.uniforms.textureEffect, this.textureEffect);
                
                // Setup attributes
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vbo);
                
                // Position attribute
                this.gl.enableVertexAttribArray(this.positionLocation);
                this.gl.vertexAttribPointer(this.positionLocation, 3, this.gl.FLOAT, false, 5 * 4, 0);
                
                // Texture coordinate attribute
                this.gl.enableVertexAttribArray(this.texCoordLocation);
                this.gl.vertexAttribPointer(this.texCoordLocation, 2, this.gl.FLOAT, false, 5 * 4, 3 * 4);
                
                // Draw triangle
                this.gl.drawArrays(this.gl.TRIANGLES, 0, 3);
                
                // Continue animation loop
                requestAnimationFrame(() => this.render());
            }
            
            updateStatus(message, type = '') {
                const status = document.getElementById('status');
                status.textContent = message;
                status.className = `status ${type}`;
                console.log(`[${type.toUpperCase()}] ${message}`);
            }
        }
        
        // Initialize when page loads
        window.addEventListener('load', () => {
            new RoseTexturedTriangleRenderer();
        });
    </script>
</body>
</html>
